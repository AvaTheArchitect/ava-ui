// ðŸŽ¸ techniqueParser - Created: September 29, 2025 12:38 PM - v1.0
// Generated by Cipher Autonomous System
// ================================================

// ðŸŽ¸ Techniqueparser - Guitar Pro Technique Parser
// src/modules/notation/parsers/techniqueParser.ts
// Parse guitar techniques from Guitar Pro files using AlphaTab API. Extract GP technique markers including hammer-on, pull-off, slide, bend, vibrato, palm muting, harmonics, tremolo picking. Convert GP technique data for tablature display. Support genre-specific techniques for Metal (palm muting, fast picking), Blues (bending, vibrato), Country (fingerpicking, chicken picking), Worship (strumming, ambient). Export class as Techniqueparser with methods parseTechniques(), getTechniqueSymbols(), applyToTab()

// ðŸŽ¸ GUITAR PRO TECHNIQUE TYPES
interface GuitarProTechniqueData {
  bends: GuitarProBend[];
  slides: GuitarProSlide[];
  vibratos: GuitarProVibrato[];
  hammerPulls: GuitarProHammerPull[];
  harmonics: GuitarProHarmonic[];
  tremoloPicking: GuitarProTremoloPicking[];
  palmMutes: GuitarProPalmMute[];
  letRings: GuitarProLetRing[];
  techniques: GuitarProTechnique[];
}

interface GuitarProBend {
  type: "bend" | "preBend" | "bendRelease" | "preBendRelease";
  value: number;
  points: Array<{ position: number; value: number; vibrato?: boolean }>;
  track: number;
  measure: number;
  beat: number;
}

interface GuitarProSlide {
  type: "slideInAbove" | "slideInBelow" | "slideOutUp" | "slideOutDown" | "shiftSlide" | "legatoSlide";
  startFret?: number;
  endFret?: number;
  track: number;
  measure: number;
}

interface GuitarProVibrato {
  type: "slight" | "wide";
  track: number;
  measure: number;
  beat: number;
}

interface GuitarProHammerPull {
  type: "hammer" | "pull";
  fromFret: number;
  toFret: number;
  track: number;
  measure: number;
}

interface GuitarProHarmonic {
  type: "natural" | "artificial" | "tapped" | "pinch" | "semi";
  fret: number;
  data?: number;
  track: number;
  measure: number;
}

interface GuitarProTremoloPicking {
  duration: string;
  track: number;
  measure: number;
}

interface GuitarProPalmMute {
  start: number;
  end: number;
  track: number;
  measure: number;
}

interface GuitarProLetRing {
  start: number;
  end: number;
  track: number;
  measure: number;
}

interface GuitarProTechnique {
  name: string;
  type: string;
  difficulty: "beginner" | "intermediate" | "advanced" | "expert";
  genre: ("rock" | "metal" | "country" | "blues")[];
  description: string;
}

interface TechniqueSymbol {
  symbol: string;
  position: { x: number; y: number };
  type: string;
  color?: string;
}

interface TabNote {
  string: number;
  fret: number;
  measure: number;
  beat: number;
  techniques: string[];
}

// ðŸŽ¸ GUITAR PRO TECHNIQUE PARSER CLASS
export class Techniqueparser {
  private readonly genreTechniques = {
    rock: ["powerChords", "palmMuting", "bending"],
    metal: ["tremoloPicking", "palmMuting", "tapHarmonics", "sweepPicking"],
    country: ["chickenPicking", "hybridPicking", "doubleStopping"],
    blues: ["bending", "vibrato", "slideGuitar", "hammerPulls"],
    jazz: ["chordMelody", "walkingBass", "arpeggios"],
  };

  private readonly techniqueSymbolMap: Record<string, string> = {
    bend: "â†‘",
    preBend: "â†‘P",
    bendRelease: "â†‘â†“",
    slideUp: "/",
    slideDown: "\\",
    hammerOn: "H",
    pullOff: "P",
    vibrato: "~",
    palmMute: "P.M.",
    letRing: "let ring",
    naturalHarmonic: "â—‡",
    artificialHarmonic: "â—†",
    tappedHarmonic: "T.H.",
    pinchHarmonic: "P.H.",
    tremoloPicking: "TP",
  };

  constructor() {
    console.log("Techniqueparser initialized for Guitar Pro technique parsing");
  }

  async parseTechniquesFromGuitarPro(gpData: any): Promise<GuitarProTechniqueData> {
    const bends = this.extractBends(gpData);
    const slides = this.extractSlides(gpData);
    const vibratos = this.extractVibratos(gpData);
    const hammerPulls = this.extractHammerPulls(gpData);
    const harmonics = this.extractHarmonics(gpData);
    const tremoloPicking = this.extractTremoloPicking(gpData);
    const palmMutes = this.extractPalmMutes(gpData);
    const letRings = this.extractLetRings(gpData);
    const techniques = this.categorizeTechniques(gpData);

    return {
      bends,
      slides,
      vibratos,
      hammerPulls,
      harmonics,
      tremoloPicking,
      palmMutes,
      letRings,
      techniques,
    };
  }

  private extractBends(gpData: any): GuitarProBend[] {
    const bends: GuitarProBend[] = [];
    if (!gpData?.tracks) return bends;

    gpData.tracks.forEach((track: any, trackIndex: number) => {
      track.staves?.[0]?.bars?.forEach((bar: any, measureIndex: number) => {
        bar.voices?.[0]?.beats?.forEach((beat: any) => {
          beat.notes?.forEach((note: any) => {
            if (note.bendType !== undefined && note.bendType !== 0) {
              const bend: GuitarProBend = {
                type: this.getBendType(note.bendType),
                value: note.bendPoints?.[note.bendPoints.length - 1]?.value || 0,
                points: note.bendPoints?.map((p: any) => ({
                  position: p.offset,
                  value: p.value,
                  vibrato: p.vibrato,
                })) || [],
                track: trackIndex,
                measure: measureIndex,
                beat: beat.index,
              };
              bends.push(bend);
            }
          });
        });
      });
    });

    return bends;
  }

  private getBendType(bendType: number): GuitarProBend["type"] {
    switch (bendType) {
      case 1: return "bend";
      case 2: return "bendRelease";
      case 3: return "preBend";
      case 4: return "preBendRelease";
      default: return "bend";
    }
  }

  private extractSlides(gpData: any): GuitarProSlide[] {
    const slides: GuitarProSlide[] = [];
    if (!gpData?.tracks) return slides;

    gpData.tracks.forEach((track: any, trackIndex: number) => {
      track.staves?.[0]?.bars?.forEach((bar: any, measureIndex: number) => {
        bar.voices?.[0]?.beats?.forEach((beat: any) => {
          beat.notes?.forEach((note: any) => {
            if (note.slideInType || note.slideOutType) {
              const slide: GuitarProSlide = {
                type: this.getSlideType(note.slideInType, note.slideOutType),
                startFret: note.fret,
                endFret: note.slideOutType ? this.calculateSlideFret(note) : undefined,
                track: trackIndex,
                measure: measureIndex,
              };
              slides.push(slide);
            }
          });
        });
      });
    });

    return slides;
  }

  private getSlideType(slideIn: number, slideOut: number): GuitarProSlide["type"] {
    if (slideIn === 1) return "slideInAbove";
    if (slideIn === 2) return "slideInBelow";
    if (slideOut === 1) return "shiftSlide";
    if (slideOut === 2) return "legatoSlide";
    if (slideOut === 3) return "slideOutDown";
    if (slideOut === 4) return "slideOutUp";
    return "shiftSlide";
  }

  private calculateSlideFret(note: any): number {
    return note.fret + (note.slideOutType === 4 ? 2 : -2);
  }

  private extractVibratos(gpData: any): GuitarProVibrato[] {
    const vibratos: GuitarProVibrato[] = [];
    if (!gpData?.tracks) return vibratos;

    gpData.tracks.forEach((track: any, trackIndex: number) => {
      track.staves?.[0]?.bars?.forEach((bar: any, measureIndex: number) => {
        bar.voices?.[0]?.beats?.forEach((beat: any) => {
          if (beat.vibrato !== undefined && beat.vibrato !== 0) {
            vibratos.push({
              type: beat.vibrato === 2 ? "wide" : "slight",
              track: trackIndex,
              measure: measureIndex,
              beat: beat.index,
            });
          }
        });
      });
    });

    return vibratos;
  }

  private extractHammerPulls(gpData: any): GuitarProHammerPull[] {
    const hammerPulls: GuitarProHammerPull[] = [];
    if (!gpData?.tracks) return hammerPulls;

    gpData.tracks.forEach((track: any, trackIndex: number) => {
      track.staves?.[0]?.bars?.forEach((bar: any, measureIndex: number) => {
        bar.voices?.[0]?.beats?.forEach((beat: any, beatIndex: number) => {
          beat.notes?.forEach((note: any, noteIndex: number) => {
            if (note.hammerPullOrigin !== undefined && note.hammerPullOrigin) {
              const nextBeat = bar.voices[0].beats[beatIndex + 1];
              const nextNote = nextBeat?.notes?.[noteIndex];
              
              if (nextNote) {
                hammerPulls.push({
                  type: nextNote.fret > note.fret ? "hammer" : "pull",
                  fromFret: note.fret,
                  toFret: nextNote.fret,
                  track: trackIndex,
                  measure: measureIndex,
                });
              }
            }
          });
        });
      });
    });

    return hammerPulls;
  }

  private extractHarmonics(gpData: any): GuitarProHarmonic[] {
    const harmonics: GuitarProHarmonic[] = [];
    if (!gpData?.tracks) return harmonics;

    gpData.tracks.forEach((track: any, trackIndex: number) => {
      track.staves?.[0]?.bars?.forEach((bar: any, measureIndex: number) => {
        bar.voices?.[0]?.beats?.forEach((beat: any) => {
          beat.notes?.forEach((note: any) => {
            if (note.harmonicType !== undefined && note.harmonicType !== 0) {
              harmonics.push({
                type: this.getHarmonicType(note.harmonicType),
                fret: note.fret,
                data: note.harmonicData,
                track: trackIndex,
                measure: measureIndex,
              });
            }
          });
        });
      });
    });

    return harmonics;
  }

  private getHarmonicType(type: number): GuitarProHarmonic["type"] {
    switch (type) {
      case 1: return "natural";
      case 2: return "artificial";
      case 3: return "tapped";
      case 4: return "pinch";
      case 5: return "semi";
      default: return "natural";
    }
  }

  private extractTremoloPicking(gpData: any): GuitarProTremoloPicking[] {
    const tremoloPicking: GuitarProTremoloPicking[] = [];
    if (!gpData?.tracks) return tremoloPicking;

    gpData.tracks.forEach((track: any, trackIndex: number) => {
      track.staves?.[0]?.bars?.forEach((bar: any, measureIndex: number) => {
        bar.voices?.[0]?.beats?.forEach((beat: any) => {
          if (beat.tremoloSpeed !== undefined && beat.tremoloSpeed !== 0) {
            tremoloPicking.push({
              duration: this.getTremoloDuration(beat.tremoloSpeed),
              track: trackIndex,
              measure: measureIndex,
            });
          }
        });
      });
    });

    return tremoloPicking;
  }

  private getTremoloDuration(speed: number): string {
    const durations = ["1/8", "1/16", "1/32"];
    return durations[speed - 1] || "1/16";
  }

  private extractPalmMutes(gpData: any): GuitarProPalmMute[] {
    const palmMutes: GuitarProPalmMute[] = [];
    if (!gpData?.tracks) return palmMutes;

    gpData.tracks.forEach((track: any, trackIndex: number) => {
      track.staves?.[0]?.bars?.forEach((bar: any, measureIndex: number) => {
        let muteStart = -1;
        bar.voices?.[0]?.beats?.forEach((beat: any, beatIndex: number) => {
          if (beat.palmMute && muteStart === -1) {
            muteStart = beatIndex;
          } else if (!beat.palmMute && muteStart !== -1) {
            palmMutes.push({
              start: muteStart,
              end: beatIndex - 1,
              track: trackIndex,
              measure: measureIndex,
            });
            muteStart = -1;
          }
        });
      });
    });

    return palmMutes;
  }

  private extractLetRings(gpData: any): GuitarProLetRing[] {
    const letRings: GuitarProLetRing[] = [];
    if (!gpData?.tracks) return letRings;

    gpData.tracks.forEach((track: any, trackIndex: number) => {
      track.staves?.[0]?.bars?.forEach((bar: any, measureIndex: number) => {
        let ringStart = -1;
        bar.voices?.[0]?.beats?.forEach((beat: any, beatIndex: number) => {
          if (beat.letRing && ringStart === -1) {
            ringStart = beatIndex;
          } else if (!beat.letRing && ringStart !== -1) {
            letRings.push({
              start: ringStart,
              end: beatIndex - 1,
              track: trackIndex,
              measure: measureIndex,
            });
            ringStart = -1;
          }
        });
      });
    });

    return letRings;
  }

  private categorizeTechniques(gpData: any): GuitarProTechnique[] {
    const techniques: GuitarProTechnique[] = [];
    const foundTechniques = new Set<string>();

    // Analyze all techniques found in the file
    if (gpData?.tracks) {
      gpData.tracks.forEach((track: any) => {
        track.staves?.[0]?.bars?.forEach((bar: any) => {
          bar.voices?.[0]?.beats?.forEach((beat: any) => {
            beat.notes?.forEach((note: any) => {
              if (note.bendType) foundTechniques.add("bending");
              if (note.slideInType || note.slideOutType) foundTechniques.add("slides");
              if (note.hammerPullOrigin) foundTechniques.add("hammerPulls");
              if (note.harmonicType) foundTechniques.add("harmonics");
            });
            if (beat.vibrato) foundTechniques.add("vibrato");
            if (beat.palmMute) foundTechniques.add("palmMuting");
            if (beat.tremoloSpeed) foundTechniques.add("tremoloPicking");
          });
        });
      });
    }

    foundTechniques.forEach((tech) => {
      techniques.push({
        name: tech,
        type: tech,
        difficulty: this.getDifficulty(tech),
        genre: this.getGenresForTechnique(tech),
        description: `${tech} technique found in file`,
      });
    });

    return techniques;
  }

  private getDifficulty(technique: string): GuitarProTechnique["difficulty"] {
    const advanced = ["tremoloPicking", "harmonics", "sweepPicking"];
    const intermediate = ["bending", "slides", "vibrato"];
    return advanced.includes(technique) ? "advanced" : 
           intermediate.includes(technique) ? "intermediate" : "beginner";
  }

  private getGenresForTechnique(technique: string): ("rock" | "metal" | "country" | "blues")[] {
    const genreMap: Record<string, ("rock" | "metal" | "country" | "blues")[]> = {
      tremoloPicking: ["metal"],
      palmMuting: ["metal", "rock"],
      bending: ["blues", "rock"],
      vibrato: ["blues", "rock"],
      hammerPulls: ["rock", "metal", "blues"],
    };
    return genreMap[technique] || ["rock"];
  }

  getTechniqueSymbols(techniqueData: GuitarProTechniqueData): TechniqueSymbol[] {
    const symbols: TechniqueSymbol[] = [];
    let yOffset = 0;

    techniqueData.bends.forEach((bend) => {
      symbols.push({
        symbol: this.techniqueSymbolMap[bend.type],
        position: { x: bend.measure * 100 + bend.beat * 20, y: yOffset },
        type: "bend",
        color: "#FF6B6B",
      });
    });

    techniqueData.slides.forEach((slide) => {
      symbols.push({
        symbol: this.techniqueSymbolMap[slide.type.includes("Up") ? "slideUp" : "slideDown"],
        position: { x: slide.measure * 100, y: yOffset + 10 },
        type: "slide",
        color: "#4ECDC4",
      });
    });

    techniqueData.hammerPulls.forEach((hp) => {
      symbols.push({
        symbol: this.techniqueSymbolMap[hp.type === "hammer" ? "hammerOn" : "pullOff"],
        position: { x: hp.measure * 100, y: yOffset + 20 },
        type: hp.type,
        color: "#95E1D3",
      });
    });

    return symbols;
  }

  applyToTab(techniqueData: GuitarProTechniqueData, tabNotes: TabNote[]): TabNote[] {
    const enhancedNotes = tabNotes.map((note) => ({ ...note }));

    techniqueData.bends.forEach((bend) => {
      const matchingNotes = enhancedNotes.filter(
        (n) => n.measure === bend.measure && n.beat === bend.beat
      );
      matchingNotes.forEach((n) => {
        if (!n.techniques) n.techniques = [];
        n.techniques.push(`bend-${bend.value}`);
      });
    });

    techniqueData.slides.forEach((slide) => {
      const matchingNotes = enhancedNotes.filter((n) => n.measure === slide.measure);
      matchingNotes.forEach((n) => {
        if (!n.techniques) n.techniques = [];
        n.techniques.push(`slide-${slide.type}`);
      });
    });

    techniqueData.hammerPulls.forEach((hp) => {
      const matchingNotes = enhancedNotes.filter((n) => n.measure === hp.measure);
      matchingNotes.forEach((n) => {
        if (!n.techniques) n.techniques = [];
        n.techniques.push(`${hp.type}-${hp.fromFret}-${hp.toFret}`);
      });
    });

    techniqueData.palmMutes.forEach((pm) => {
      const matchingNotes = enhancedNotes.filter(
        (n) => n.measure === pm.measure && n.beat >= pm.start && n.beat <= pm.end
      );
      matchingNotes.forEach((n) => {
        if (!n.techniques) n.techniques = [];
        n.techniques.push("palmMute");
      });
    });

    return enhancedNotes;
  }

  static create(): Techniqueparser {
    return new Techniqueparser();
  }
}

export default Techniqueparser;