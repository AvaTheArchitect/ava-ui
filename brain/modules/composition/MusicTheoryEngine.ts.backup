/**
 * ðŸŽ¼ MusicTheoryEngine - Comprehensive Music Intelligence Foundation
 * ================================================================
 * File: brain/modules/composition/MusicTheoryEngine.ts
 *
 * Core music theory intelligence engine that powers all musical analysis,
 * generation, and suggestion features across Rock, Metal, Country,
 * Blues/Rock, and Contemporary Christian genres.
 */

// Import shared brain types and utilities (Cipher pattern - explicit imports)
import { generateId } from "../../shared/utils";
import {
  AudioFeatures,
  Key,
  Scale,
  ChordProgression,
  GenreCharacteristics,
  MusicTheoryHarmonyAnalysis,
} from "../../shared/types";

// Import music constants from utils (Cipher pattern)
import {
  CHROMATIC_NOTES,
  CIRCLE_OF_FIFTHS,
  SCALE_PATTERNS,
  CHORD_INTERVALS,
  KEY_ANALYSIS_WEIGHTS,
  TEMPO_THRESHOLDS,
  AUDIO_ANALYSIS,
  STEP_PROBABILITIES,
  DEFAULTS,
  ROMAN_NUMERALS,
  NUMERAL_TO_INDEX,
  HARMONIC_FUNCTIONS,
  KEY_SIGNATURES,
  CHORD_QUALITIES,
  CADENCE_PATTERNS,
  type ScalePatternKey,
} from "../../shared/utils";

export class MusicTheoryEngine {
  // Genre-specific characteristics
  private readonly GENRE_CHARACTERISTICS: {
    [key: string]: GenreCharacteristics;
  } = {
    rock: {
      commonProgressions: [
        ["I", "V", "vi", "IV"], // vi-IV-I-V (very common)
        ["I", "bVII", "IV", "I"], // I-bVII-IV-I
        ["vi", "IV", "I", "V"], // vi-IV-I-V
        ["I", "IV", "V", "I"], // Classic I-IV-V-I
      ],
      preferredKeys: ["E", "A", "D", "G", "C", "F"],
      typicalChords: ["power chords", "major triads", "dominant 7th"],
      avoidedChords: ["maj7", "add9", "sus2"],
      rhythmFeatures: ["strong backbeat", "4/4 time", "driving rhythm"],
      modalInterchange: true,
      complexity: "moderate",
    },
    metal: {
      commonProgressions: [
        ["i", "bVI", "bVII", "i"], // Minor progressions
        ["i", "bIII", "bVII", "bVI"], // Aeolian progressions
        ["i", "iv", "V", "i"], // Harmonic minor
        ["i", "bII", "bVII", "i"], // Phrygian dominant
      ],
      preferredKeys: ["E", "B", "F#", "C#", "D", "A"], // Lower tunings
      typicalChords: ["power chords", "diminished", "minor triads"],
      avoidedChords: ["major 7th", "add9", "sus chords"],
      rhythmFeatures: ["complex rhythms", "odd time signatures", "palm muting"],
      modalInterchange: true,
      complexity: "complex",
    },
    country: {
      commonProgressions: [
        ["I", "V", "vi", "IV"], // Classic country
        ["I", "IV", "I", "V"], // Simple progression
        ["vi", "V", "I", "IV"], // Relative minor start
        ["I", "vi", "IV", "V"], // Circle progression
      ],
      preferredKeys: ["G", "C", "D", "A", "E", "F"],
      typicalChords: ["major triads", "dominant 7th", "sus4", "add9"],
      avoidedChords: ["diminished", "augmented", "complex extensions"],
      rhythmFeatures: ["shuffle feel", "3/4 waltz", "train beat"],
      modalInterchange: false,
      complexity: "simple",
    },
    "blues-rock": {
      commonProgressions: [
        [
          "I7",
          "I7",
          "I7",
          "I7",
          "IV7",
          "IV7",
          "I7",
          "I7",
          "V7",
          "IV7",
          "I7",
          "V7",
        ], // 12-bar blues
        ["i", "iv", "i", "V7"], // Minor blues
        ["I", "V", "vi", "IV"], // Blues rock hybrid
        ["i", "bVII", "IV", "i"], // Modal blues
      ],
      preferredKeys: ["E", "A", "B", "G", "C", "F"],
      typicalChords: [
        "dominant 7th",
        "9th chords",
        "power chords",
        "minor pentatonic",
      ],
      avoidedChords: ["major 7th", "sus2", "add2"],
      rhythmFeatures: ["shuffle rhythm", "12/8 feel", "swing"],
      modalInterchange: true,
      complexity: "moderate",
    },
    "contemporary-christian": {
      commonProgressions: [
        ["vi", "IV", "I", "V"], // Very popular in worship
        ["I", "V", "vi", "IV"], // Classic progression
        ["vi", "V", "I", "IV"], // Emotional build
        ["I", "vi", "IV", "V"], // Traditional hymn style
      ],
      preferredKeys: ["G", "C", "D", "A", "E", "F"],
      typicalChords: ["major triads", "sus4", "add9", "major 7th"],
      avoidedChords: ["diminished", "augmented", "complex jazz chords"],
      rhythmFeatures: ["gentle rhythm", "4/4 time", "anthemic builds"],
      modalInterchange: false,
      complexity: "simple",
    },
  };

  constructor() {
    this.initializeEngine();
  }

  /**
   * Initialize the engine with proper ID tracking
   */
  private initializeEngine(): void {
    const engineId = generateId("music-theory-engine");
    if (engineId) {
      // Engine successfully initialized with unique ID
      // Ready for music analysis and generation
    }
  }

  /**
   * Analyze harmony from chord progression
   */
  public analyzeHarmony(
    chords: string[],
    detectedKey?: string
  ): MusicTheoryHarmonyAnalysis {
    const key = detectedKey
      ? this.parseKey(detectedKey)
      : this.detectKey(chords);
    const numerals = this.chordsToNumerals(chords, key);
    const functions = this.analyzeFunctions(numerals);
    const cadences = this.detectCadences(numerals);
    const modulations = this.detectModulations(chords);
    const confidence = this.calculateConfidence(chords, key);

    return {
      key,
      chords,
      numerals,
      functions,
      cadences,
      modulations,
      nonChordTones: [], // Would need audio analysis
      confidence,
    };
  }

  /**
   * Suggest chords based on key and genre (matches test expectations)
   */
  public suggestChords(
    key: string,
    genre: string = "rock"
  ): string[] {
    const keyObj = this.parseKey(key);
    const genreChar = this.GENRE_CHARACTERISTICS[genre];
    const suggestions: string[] = [];

    // Get common progressions for genre
    const commonProgressions = genreChar.commonProgressions;
    
    // Extract chords from common progressions
    commonProgressions.forEach(progression => {
      progression.slice(0, 3).forEach(numeral => {
        const chord = this.numeralToChord(numeral, keyObj);
        if (chord && !suggestions.includes(chord)) {
          suggestions.push(chord);
        }
      });
    });

    return suggestions.slice(0, DEFAULTS.SUGGESTION_COUNT || 6);
  }

  /**
   * Generate melody based on key, scale, and parameters
   */
  public generateMelody(
    key: string,
    scale: ScalePatternKey = "major",
    length: number,
    genre: string = "rock"
  ): string[] {
    const keyObj = this.parseKey(key);
    const scalePattern = this.getScalePattern(scale);
    const scaleNotes = this.generateScale(keyObj.tonic, [...scalePattern]);

    const melody: string[] = [];
    const genreChar = this.GENRE_CHARACTERISTICS[genre];
    const complexity = genreChar.complexity;
    const stepProbability = STEP_PROBABILITIES[complexity] || 0.7;

    // Genre-specific melody generation logic
    for (let i = 0; i < length; i++) {
      const note = this.generateMelodyNote(
        i,
        melody,
        scaleNotes,
        stepProbability
      );
      melody.push(note);
    }

    return melody;
  }

  /**
   * Get scale information - FIXED: proper closing brace and readonly array handling
   */
  public getScale(tonic: string, scaleName: ScalePatternKey): Scale {
    const pattern = SCALE_PATTERNS[scaleName];
    if (!pattern) {
      throw new Error(`Unknown scale: ${scaleName}`);
    }

    const notes = this.generateScale(tonic, [...pattern]);
    const chords = this.generateScaleChords(tonic, [...pattern]);
    const modes = this.generateModes(scaleName);

    return {
      name: `${tonic} ${scaleName}`,
      intervals: [...pattern],  // FIXED: spread to make mutable array
      notes,
      chords,
      modes,
    };
  } // FIXED: Added missing closing brace

  /**
   * Detect key from chord progression
   */
  public detectKey(chords: string[]): Key {
    const majorScores: { [key: string]: number } = {};
    const minorScores: { [key: string]: number } = {};

    // Score each possible key
    CHROMATIC_NOTES.forEach((tonic) => {
      majorScores[tonic] = this.scoreKeyFit(chords, tonic, "major");
      minorScores[tonic] = this.scoreKeyFit(chords, tonic, "minor");
    });

    // Find best fitting key
    const bestMajor = this.findBestKey(majorScores);
    const bestMinor = this.findBestKey(minorScores);

    if (majorScores[bestMajor] > minorScores[bestMinor]) {
      return this.createKeyObject(bestMajor, "major");
    } else {
      return this.createKeyObject(bestMinor, "minor");
    }
  }

  /**
   * Analyze audio features for music theory insights
   */
  public analyzeAudioFeatures(
    audioFeatures: AudioFeatures
  ): MusicTheoryHarmonyAnalysis {
    const keyObj = this.parseKey(audioFeatures.key);
    const tempo = audioFeatures.tempo;
    const confidence = audioFeatures.confidence;

    // Generate chord suggestions based on audio analysis
    const scalePattern = this.getScalePatternForMode(keyObj.mode);
    const scaleChords = this.generateScaleChords(keyObj.tonic, scalePattern);

    // Adjust analysis based on tempo
    const tempoBasedComplexity = this.getTempoBasedComplexity(tempo);
    const chordsToAnalyze = this.getChordsForComplexity(
      scaleChords,
      tempoBasedComplexity
    );

    return {
      key: keyObj,
      chords: chordsToAnalyze,
      numerals: ROMAN_NUMERALS.major.slice(0, chordsToAnalyze.length),
      functions: this.generateFunctionsForChords(chordsToAnalyze.length),
      cadences: [],
      modulations: [],
      nonChordTones: [],
      confidence: confidence * (AUDIO_ANALYSIS.CONFIDENCE_ADJUSTMENT || 0.9),
    };
  }

  /**
   * Get genre characteristics
   */
  public getGenreCharacteristics(genre: string): GenreCharacteristics {
    return this.GENRE_CHARACTERISTICS[genre] || this.GENRE_CHARACTERISTICS.rock;
  }

  /**
   * Generate chord progression for specific genre
   */
  public generateChordProgression(
    key: string,
    genre: string,
    length: number = DEFAULTS.CHORD_PROGRESSION_LENGTH || 4
  ): ChordProgression {
    const genreChar = this.getGenreCharacteristics(genre);
    const keyObj = this.parseKey(key);

    // Choose random common progression for genre
    const progressions = genreChar.commonProgressions;
    const chosenProgression = this.selectRandomProgression(progressions);

    // Convert numerals to actual chords
    const { chords, numerals } = this.buildChordProgression(
      chosenProgression,
      keyObj,
      genre,
      length
    );

    return {
      numerals,
      chords,
      key: key,
      genre,
      commonality: "common",
      emotional: this.getProgressionEmotion(numerals),
    };
  }

  // Private helper methods (refactored for better organization)

  private findProgressionSuggestions(
    progressions: string[][],
    lastNumeral: string,
    key: Key,
    suggestions: string[]
  ): void {
    for (const progression of progressions) {
      const lastIndex = progression.lastIndexOf(lastNumeral);
      if (lastIndex !== -1 && lastIndex < progression.length - 1) {
        const nextNumeral = progression[lastIndex + 1];
        const chord = this.numeralToChord(nextNumeral, key);
        if (chord && !suggestions.includes(chord)) {
          suggestions.push(chord);
        }
      }
    }
  }

  private addUniqueSuggestions(
    suggestions: string[],
    newSuggestions: string[]
  ): void {
    newSuggestions.forEach((chord) => {
      if (!suggestions.includes(chord)) {
        suggestions.push(chord);
      }
    });
  }

  private generateMelodyNote(
    index: number,
    melody: string[],
    scaleNotes: string[],
    stepProbability: number
  ): string {
    if (index === 0) {
      // Start on tonic or fifth
      return Math.random() > (DEFAULTS.START_ON_FIFTH_PROBABILITY || 0.3)
        ? scaleNotes[0]
        : scaleNotes[4] || scaleNotes[0];
    }

    const lastNote = melody[index - 1];
    const lastIndex = scaleNotes.indexOf(lastNote);

    if (Math.random() < stepProbability) {
      // Step-wise motion
      const direction =
        Math.random() > (DEFAULTS.STEP_DIRECTION_PROBABILITY || 0.5) ? 1 : -1;
      const newIndex = Math.max(
        0,
        Math.min(scaleNotes.length - 1, lastIndex + direction)
      );
      return scaleNotes[newIndex];
    } else {
      // Leap
      return scaleNotes[Math.floor(Math.random() * scaleNotes.length)];
    }
  }

  private findBestKey(scores: { [key: string]: number }): string {
    return Object.keys(scores).reduce((a, b) =>
      scores[a] > scores[b] ? a : b
    );
  }

  private createKeyObject(tonic: string, mode: "major" | "minor"): Key {
    return {
      tonic,
      mode,
      signature: this.getKeySignature(tonic, mode),
    };
  }

  private getScalePatternForMode(mode: "major" | "minor"): number[] {
    return mode === "major" ? [...SCALE_PATTERNS.major] : [...SCALE_PATTERNS.minor];
  }

  private getTempoBasedComplexity(tempo: number): "fast" | "moderate" | "slow" {
    if (tempo > (TEMPO_THRESHOLDS.FAST || 140)) return "fast";
    if (tempo > (TEMPO_THRESHOLDS.MODERATE || 100)) return "moderate";
    return "slow";
  }

  private getChordsForComplexity(
    scaleChords: string[],
    complexity: "fast" | "moderate" | "slow"
  ): string[] {
    const chordCounts = { fast: 3, moderate: 4, slow: 4 };
    return scaleChords.slice(0, chordCounts[complexity]);
  }

  private generateFunctionsForChords(count: number): string[] {
    const functions = ["Tonic", "Subdominant", "Mediant", "Subdominant"];
    return functions.slice(0, count);
  }

  private selectRandomProgression(progressions: string[][]): string[] {
    return progressions[Math.floor(Math.random() * progressions.length)];
  }

  private buildChordProgression(
    chosenProgression: string[],
    keyObj: Key,
    genre: string,
    length: number
  ): { chords: string[]; numerals: string[] } {
    const chords: string[] = [];
    const numerals = chosenProgression.slice(0, length);

    numerals.forEach((numeral) => {
      const chord = this.numeralToChord(numeral, keyObj);
      if (chord) {
        chords.push(chord);
      }
    });

    // Fill in missing chords if needed
    this.fillMissingChords(chords, genre, length);

    return { chords, numerals };
  }

  private fillMissingChords(
    chords: string[],
    genre: string,
    targetLength: number
  ): void {
    while (chords.length < targetLength && chords.length > 0) {
      const lastChord = chords[chords.length - 1];
      const suggestions = this.suggestChords(lastChord, genre);
      const suggestedChord =
        suggestions.length > 0 ? suggestions[0] : lastChord;
      chords.push(suggestedChord);
    }
  }

  // Rest of the helper methods with constants from utils
  private parseKey(keyString: string): Key {
    const isMinor =
      keyString.toLowerCase().includes("m") &&
      !keyString.toLowerCase().includes("maj");
    const tonic = keyString.replace(/[^A-G#b]/g, "");

    return {
      tonic,
      mode: isMinor ? "minor" : "major",
      signature: this.getKeySignature(tonic, isMinor ? "minor" : "major"),
    };
  }

  private generateScale(tonic: string, intervals: number[]): string[] {
    const tonicIndex = CHROMATIC_NOTES.indexOf(tonic as any);
    if (tonicIndex === -1) {
      throw new Error(`Invalid tonic: ${tonic}`);
    }

    return intervals.map((interval) => {
      const noteIndex = (tonicIndex + interval) % CHROMATIC_NOTES.length;
      return CHROMATIC_NOTES[noteIndex];
    });
  }

  private generateScaleChords(tonic: string, intervals: number[]): string[] {
    const scale = this.generateScale(tonic, intervals);
    const chords: string[] = [];

    for (let i = 0; i < scale.length; i++) {
      const root = scale[i];
      const third = scale[(i + 2) % scale.length];
      const fifth = scale[(i + 4) % scale.length];
      const chordQuality = this.determineChordQuality(root, third, fifth);
      chords.push(`${root}${chordQuality}`);
    }

    return chords;
  }

  private determineChordQuality(
    root: string,
    third: string,
    fifth: string
  ): string {
    const rootIndex = CHROMATIC_NOTES.indexOf(root as any);
    const thirdIndex = CHROMATIC_NOTES.indexOf(third as any);
    const fifthIndex = CHROMATIC_NOTES.indexOf(fifth as any);

    const thirdInterval =
      (thirdIndex - rootIndex + CHROMATIC_NOTES.length) %
      CHROMATIC_NOTES.length;
    const fifthInterval =
      (fifthIndex - rootIndex + CHROMATIC_NOTES.length) %
      CHROMATIC_NOTES.length;

    if (
      thirdInterval === (CHORD_INTERVALS.major?.third || 4) &&
      fifthInterval === (CHORD_INTERVALS.major?.fifth || 7)
    ) {
      return CHORD_QUALITIES.MAJOR || "";
    } else if (
      thirdInterval === (CHORD_INTERVALS.minor?.third || 3) &&
      fifthInterval === (CHORD_INTERVALS.minor?.fifth || 7)
    ) {
      return CHORD_QUALITIES.MINOR || "m";
    } else if (fifthInterval === (CHORD_INTERVALS.diminished?.fifth || 6)) {
      return CHORD_QUALITIES.DIMINISHED || "Â°";
    } else if (fifthInterval === (CHORD_INTERVALS.augmented?.fifth || 8)) {
      return CHORD_QUALITIES.AUGMENTED || "+";
    }
    return CHORD_QUALITIES.MAJOR || "";
  }

  private scoreKeyFit(
    chords: string[],
    tonic: string,
    mode: "major" | "minor"
  ): number {
    const pattern =
      mode === "major" ? [...SCALE_PATTERNS.major] : [...SCALE_PATTERNS.minor];
    const scaleNotes = this.generateScale(tonic, pattern);
    let score = 0;

    chords.forEach((chord) => {
      const chordRoot = chord.replace(/[^A-G#b]/g, "");
      if (scaleNotes.includes(chordRoot)) {
        if (chordRoot === tonic) {
          score += KEY_ANALYSIS_WEIGHTS.TONIC_SCORE || 5;
        } else if (chordRoot === scaleNotes[4]) {
          score += KEY_ANALYSIS_WEIGHTS.DOMINANT_SCORE || 3;
        } else {
          score += KEY_ANALYSIS_WEIGHTS.SCALE_NOTE_SCORE || 1;
        }
      }

      if (mode === "minor" && chord.includes("m")) {
        score += KEY_ANALYSIS_WEIGHTS.MODE_BONUS_SCORE || 2;
      } else if (
        mode === "major" &&
        !chord.includes("m") &&
        !chord.includes("Â°")
      ) {
        score += KEY_ANALYSIS_WEIGHTS.MODE_BONUS_SCORE || 2;
      }
    });

    return score;
  }

  private chordsToNumerals(chords: string[], key: Key): string[] {
    const scalePattern = this.getScalePatternForMode(key.mode);
    const scaleNotes = this.generateScale(key.tonic, scalePattern);

    return chords.map((chord) => {
      const chordRoot = chord.replace(/[^A-G#b]/g, "");
      const scaleIndex = scaleNotes.indexOf(chordRoot);

      if (scaleIndex !== -1) {
        const numerals =
          key.mode === "major" ? ROMAN_NUMERALS.major : ROMAN_NUMERALS.minor;
        return numerals[scaleIndex] || "N/A";
      }

      return "N/A";
    });
  }

  private analyzeFunctions(numerals: string[]): string[] {
    return numerals.map((numeral) => {
      const upperNumeral = numeral.toUpperCase();
      const lowerNumeral = numeral.toLowerCase();

      // Safe checking with fallbacks for HARMONIC_FUNCTIONS
      const tonicFunctions = HARMONIC_FUNCTIONS?.TONIC || ["I", "i", "vi", "VI"];
      const subdominantFunctions = HARMONIC_FUNCTIONS?.SUBDOMINANT || ["IV", "iv", "ii", "iiÂ°"];  
      const dominantFunctions = HARMONIC_FUNCTIONS?.DOMINANT || ["V", "viiÂ°", "v", "VII"];

      if (
        tonicFunctions.includes(numeral) ||
        tonicFunctions.includes(upperNumeral) ||
        tonicFunctions.includes(lowerNumeral)
      ) {
        return "Tonic";
      } else if (
        subdominantFunctions.includes(numeral) ||
        subdominantFunctions.includes(upperNumeral) ||
        subdominantFunctions.includes(lowerNumeral)
      ) {
        return "Subdominant";
      } else if (
        dominantFunctions.includes(numeral) ||
        dominantFunctions.includes(upperNumeral) ||
        dominantFunctions.includes(lowerNumeral)
      ) {
        return "Dominant";
      }

      return "Other";
    });
  }

  private detectCadences(numerals: string[]): string[] {
    const cadences: string[] = [];

    for (let i = 0; i < numerals.length - 1; i++) {
      const current = numerals[i];
      const next = numerals[i + 1];
      const cadenceType = this.identifyCadence(current, next);

      if (cadenceType) {
        cadences.push(cadenceType);
      }
    }

    return cadences;
  }

  private identifyCadence(current: string, next: string): string | null {
    const cadencePatterns = CADENCE_PATTERNS || {};
    
    for (const [cadenceName, patterns] of Object.entries(cadencePatterns)) {
      for (const pattern of patterns as string[][]) {
        if (pattern[0] === current && pattern[1] === next) {
          return (
            cadenceName.charAt(0).toUpperCase() +
            cadenceName.slice(1) +
            " Cadence"
          );
        }
      }
    }
    return null;
  }

  private detectModulations(chords: string[]): string[] {
    const modulations: string[] = [];

    for (let i = 0; i < chords.length - 1; i++) {
      const currentChord = chords[i];
      if (currentChord.includes("#") || currentChord.includes("b")) {
        modulations.push(`Potential modulation at chord ${i + 1}`);
      }
    }

    return modulations;
  }

  private calculateConfidence(chords: string[], key: Key): number {
    const score = this.scoreKeyFit(chords, key.tonic, key.mode);
    return Math.min(score / chords.length, AUDIO_ANALYSIS.MAX_CONFIDENCE || 100);
  }

  private getTheoryBasedSuggestions(
    currentNumeral: string,
    key: Key
  ): string[] {
    const suggestions: string[] = [];
    const progressionMap: { [key: string]: string[] } = {
      i: ["iv", "V", "vi"],
      iv: ["I", "V", "ii"],
      v: ["I", "vi"],
      vi: ["IV", "I", "V"],
    };

    const suggestedNumerals =
      progressionMap[currentNumeral.toLowerCase()] || [];

    suggestedNumerals.forEach((numeral) => {
      const chord = this.numeralToChord(numeral, key);
      if (chord) suggestions.push(chord);
    });

    return suggestions;
  }

  private numeralToChord(numeral: string, key: Key): string | null {
    const scalePattern = this.getScalePatternForMode(key.mode);
    const scaleNotes = this.generateScale(key.tonic, scalePattern);

    const cleanNumeral = numeral.replace(/[Â°+]/g, "");
    const scaleIndex =
      NUMERAL_TO_INDEX[cleanNumeral as keyof typeof NUMERAL_TO_INDEX];

    if (scaleIndex !== undefined && scaleNotes[scaleIndex]) {
      const root = scaleNotes[scaleIndex];
      const isMinor =
        numeral.toLowerCase() === numeral &&
        !["iv", "v"].includes(numeral.toLowerCase());
      return isMinor ? `${root}m` : root;
    }

    return null;
  }

  private getKeySignature(tonic: string, mode: "major" | "minor"): string {
    const circleIndex = CIRCLE_OF_FIFTHS.indexOf(tonic as any);
    if (circleIndex === -1) return "0";

    let signature: string;

    if (circleIndex <= (KEY_SIGNATURES.CIRCLE_MIDPOINT || 6)) {
      signature = `${circleIndex}#`;
    } else {
      signature = `${CHROMATIC_NOTES.length - circleIndex}b`;
    }

    if (mode === "minor") {
      const adjustedIndex =
        circleIndex <= (KEY_SIGNATURES.MINOR_KEY_ADJUSTMENT || 3)
          ? circleIndex + (KEY_SIGNATURES.MINOR_KEY_ADJUSTMENT || 3)
          : circleIndex - (KEY_SIGNATURES.MINOR_KEY_ADJUSTMENT || 3);

      if (adjustedIndex <= (KEY_SIGNATURES.CIRCLE_MIDPOINT || 6)) {
        signature = `${adjustedIndex}#`;
      } else {
        signature = `${CHROMATIC_NOTES.length - adjustedIndex}b`;
      }
    }

    return signature;
  }

  private getScalePattern(scaleName: ScalePatternKey): readonly number[] {
    return SCALE_PATTERNS[scaleName];
  }

  private generateModes(scaleName: string): string[] {
    if (scaleName === "major") {
      return [
        "Ionian",
        "Dorian",
        "Phrygian",
        "Lydian",
        "Mixolydian",
        "Aeolian",
        "Locrian",
      ];
    }
    return [];
  }

  private getProgressionEmotion(
    numerals: string[]
  ): "happy" | "sad" | "tense" | "resolved" | "mysterious" | "powerful" {
    const minorChords = numerals.filter((n) => n.toLowerCase() === n).length;
    const hasV = numerals.some((n) => n.toLowerCase() === "v");
    const hasI = numerals.some((n) => n.toLowerCase() === "i");

    if (minorChords > numerals.length / 2) return "sad";
    if (hasV && hasI) return "resolved";
    if (hasV) return "tense";
    if (numerals.includes("vi") || numerals.includes("VI")) return "mysterious";
    return "happy";
  }
}
